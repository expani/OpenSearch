/*
 * SPDX-License-Identifier: Apache-2.0
 *
 * The OpenSearch Contributors require contributions made to
 * this file be licensed under the Apache-2.0 license or a
 * compatible open source license.
 */

apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'opensearch.internal-cluster-test'
apply plugin: 'opensearch.yaml-rest-test'
apply plugin: 'opensearch.pluginzip'

def pluginName = 'engine-datafusion'
def pluginDescription = 'OpenSearch plugin providing access to DataFusion via JNI'
def projectPath = 'org.opensearch'
def pathToPlugin = 'datafusion.DataFusionPlugin'
def pluginClassName = 'DataFusionPlugin'

repositories {
    maven {
        url = 'https://aws.oss.sonatype.org/content/repositories/snapshots/'
    }
    maven {
        url = 'https://repo1.maven.org/maven2/'
    }
    mavenCentral()
}

opensearchplugin {
    name = pluginName
    description = pluginDescription
    classname = "${projectPath}.${pathToPlugin}"
    licenseFile = rootProject.file('LICENSE.txt')
    noticeFile = rootProject.file('NOTICE.txt')
}

dependencies {
    implementation "org.apache.logging.log4j:log4j-api:${versions.log4j}"
    implementation "org.apache.logging.log4j:log4j-core:${versions.log4j}"
    
    // Bundle Jackson in the plugin JAR using 'api' like other OpenSearch plugins
    api "com.fasterxml.jackson.core:jackson-core:${versions.jackson}"
    api "com.fasterxml.jackson.core:jackson-databind:${versions.jackson_databind}"
    api "com.fasterxml.jackson.core:jackson-annotations:${versions.jackson}"

    testImplementation "junit:junit:${versions.junit}"
    testImplementation "org.hamcrest:hamcrest:${versions.hamcrest}"
    testImplementation "org.mockito:mockito-core:${versions.mockito}"
}

// Task to build the Rust JNI library
task buildRustLibrary(type: Exec) {
    description = 'Build the Rust JNI library using Cargo'
    group = 'build'

    workingDir file('jni')

    // Determine the target directory and library name based on OS
    def osName = System.getProperty('os.name').toLowerCase()
    def libPrefix = osName.contains('windows') ? '' : 'lib'
    def libExtension = osName.contains('windows') ? '.dll' : (osName.contains('mac') ? '.dylib' : '.so')

    // Use debug build for development, release for production
    def buildType = project.hasProperty('rustRelease') ? 'release' : 'debug'
    def targetDir = "target/${buildType}"

    // Find cargo executable
    def cargoExec = System.getenv('CARGO_HOME') ? "${System.getenv('CARGO_HOME')}/bin/cargo" :
                   (System.getProperty('user.home') + '/.cargo/bin/cargo')

    def cargoArgs = [cargoExec, 'build']
    if (buildType == 'release') {
        cargoArgs.add('--release')
    }

    commandLine cargoArgs

    // Set environment variables for cross-compilation if needed
    environment 'CARGO_TARGET_DIR', file('jni/target').absolutePath

    inputs.files fileTree('jni/src')
    inputs.file 'jni/Cargo.toml'
    outputs.files file("jni/${targetDir}/${libPrefix}opensearch_datafusion_jni${libExtension}")
    System.out.println("Building Rust library in ${buildType} mode");
}

// Task to copy the native library to resources
task copyNativeLibrary(type: Copy, dependsOn: buildRustLibrary) {
    description = 'Copy the native library to Java resources'
    group = 'build'

    def osName = System.getProperty('os.name').toLowerCase()
    def libPrefix = osName.contains('windows') ? '' : 'lib'
    def libExtension = osName.contains('windows') ? '.dll' : (osName.contains('mac') ? '.dylib' : '.so')
    def buildType = project.hasProperty('rustRelease') ? 'release' : 'debug'

    from file("jni/target/${buildType}/${libPrefix}opensearch_datafusion_jni${libExtension}")
    into file('src/main/resources/native')

    // Rename to a standard name for Java to load
    rename { filename ->
        "libopensearch_datafusion_jni${libExtension}"
    }

    // Fix file permissions - native libraries shouldn't be executable
    doLast {
        def targetFile = file("${destinationDir}/libopensearch_datafusion_jni${libExtension}")
        targetFile.setExecutable(false, false)  // Remove execute for owner and others
        targetFile.setReadable(true, false)     // Keep readable for all
        targetFile.setWritable(true, true)      // Keep writable for owner only
    }
}

// Ensure native library is built before Java compilation
compileJava.dependsOn copyNativeLibrary

// Ensure processResources depends on copyNativeLibrary
processResources.dependsOn copyNativeLibrary

// Ensure sourcesJar depends on copyNativeLibrary since it includes resources
sourcesJar.dependsOn copyNativeLibrary

// Ensure other tasks that use resources depend on copyNativeLibrary
tasks.withType(org.gradle.api.tasks.bundling.Jar) {
    dependsOn copyNativeLibrary
}
tasks.matching { it.name in ['filepermissions', 'licenseHeaders', 'forbiddenPatterns', 'spotlessJava', 'spotlessJavaCheck'] }.configureEach {
    dependsOn copyNativeLibrary
}

// Clean task should also clean Rust artifacts
clean {
    delete file('jni/target')
    delete file('src/main/resources/native')
}

// Exclude native libraries from pattern checking
forbiddenPatterns {
    exclude '**/*.dylib'
    exclude '**/*.so'
    exclude '**/*.dll'
}

test {
    // Set system property to help tests find the native library
    systemProperty 'java.library.path', file('src/main/resources/native').absolutePath
}

yamlRestTest {
    systemProperty 'tests.security.manager', 'false'
    // Add the native library path for integration tests
    systemProperty 'java.library.path', file('src/main/resources/native').absolutePath
    // Disable DataFusion service for integration tests by default
    systemProperty 'opensearch.experimental.feature.datafusion.enabled', 'false'
}
